import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:shopple/services/chat/chat_repository.dart';
import 'package:shopple/services/chat/i_chat_repository.dart';
import 'package:stream_chat_flutter/stream_chat_flutter.dart';
import 'package:stream_chat/src/core/http/token.dart';
import 'package:firebase_auth/firebase_auth.dart' as firebase_auth;
import 'package:fake_cloud_firestore/fake_cloud_firestore.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:stream_chat/stream_chat.dart';

import '../../mocks/mock_classes.mocks.dart';

void main() {
  late ChatRepository chatRepository;
  late MockAuthService mockAuthService;
  late MockStreamChatClient mockStreamChatClient;
  late FakeFirebaseFirestore fakeFirestore;

  setUp(() {
    dotenv.testLoad(fileInput: "STREAM_CHAT_API_SECRET=test_secret");
    mockAuthService = MockAuthService();
    mockStreamChatClient = MockStreamChatClient();
    fakeFirestore = FakeFirebaseFirestore();
    chatRepository = ChatRepository(
      mockAuthService,
      mockStreamChatClient,
      firestore: fakeFirestore,
    );
  });

  group('ChatRepository Tests', () {
    test(
      'connectTheCurrentUser returns success when user is authenticated',
      () async {
        // Arrange
        final fakeUser = FakeUser(
          uid: 'test_uid',
          displayName: 'Test User',
          photoURL: 'https://example.com/photo.jpg',
        );

        when(mockAuthService.currentUser).thenReturn(fakeUser);

        // Populate Fake Firestore
        await fakeFirestore.collection('users').doc('test_uid').set({
          'firstName': 'Test',
          'lastName': 'User',
          'photoURL': 'https://example.com/photo.jpg',
        });

        // Mock Stream Chat Client state
        final mockState = MockClientState();
        when(mockStreamChatClient.state).thenReturn(mockState);
        when(mockState.currentUser).thenReturn(null); // Not connected yet

        // Stub devToken
        when(mockStreamChatClient.devToken(any)).thenReturn(FakeToken());

        when(mockStreamChatClient.connectUser(any, any)).thenAnswer(
          (_) async => OwnUser(
            id: 'test_uid',
            name: 'Test User',
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ),
        );

        // Act
        final result = await chatRepository.connectTheCurrentUser();

        // Assert
        expect(result.isRight(), true);
        verify(mockStreamChatClient.connectUser(any, any)).called(1);
      },
    );

    test(
      'connectTheCurrentUser returns failure when user is not authenticated',
      () async {
        // Arrange
        when(mockAuthService.currentUser).thenReturn(null);

        // Act
        final result = await chatRepository.connectTheCurrentUser();

        // Assert
        expect(result.isLeft(), true);
        result.fold(
          (l) => expect(l, ChatFailureEnum.permissionDenied),
          (r) => fail('Should have returned failure'),
        );
        verifyNever(mockStreamChatClient.connectUser(any, any));
      },
    );
  });
}

// Mock class for Firebase User since it's not generated by build_runner easily
class MockUser extends Mock implements firebase_auth.User {
  @override
  String get uid =>
      super.noSuchMethod(Invocation.getter(#uid), returnValue: 'test_uid');

  @override
  String? get displayName => super.noSuchMethod(
    Invocation.getter(#displayName),
    returnValue: 'Test User',
  );

  @override
  String? get photoURL =>
      super.noSuchMethod(Invocation.getter(#photoURL), returnValue: null);
}

class MockClientState extends Mock implements ClientState {
  @override
  OwnUser? get currentUser =>
      super.noSuchMethod(Invocation.getter(#currentUser), returnValue: null);
}

class FakeToken extends Fake implements Token {
  @override
  String get rawValue => 'dummy_token';
}

class FakeUser extends Fake implements firebase_auth.User {
  @override
  final String uid;
  @override
  final String? displayName;
  @override
  final String? photoURL;
  @override
  final bool emailVerified;
  @override
  final String? email;
  @override
  final String? phoneNumber;

  FakeUser({
    required this.uid,
    this.displayName,
    this.photoURL,
    this.emailVerified = true,
    this.email = 'test@example.com',
    this.phoneNumber,
  });
}
